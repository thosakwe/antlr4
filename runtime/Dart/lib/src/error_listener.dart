import 'atn/atn_config_set.dart';
import 'util/bit_set.dart';
import 'dfa.dart';
import 'exceptions.dart';
import 'recognizer.dart';
import 'parser.dart';

/// How to emit recognition errors.
class ErrorListener {
  /// Upon syntax error, notify any interested parties. This is not how to
  /// recover from errors or compute error messages. [ErrorStrategy]
  /// specifies how to recover from syntax errors and how to compute error
  /// messages. This listener's job is simply to emit a computed message,
  /// though it has enough information to create its own message in many cases.
  ///
  /// The [RecognitionException] is non-null for all syntax errors except
  /// when we discover mismatched token errors that we can recover from
  /// in-line, without returning from the surrounding rule (via the single
  /// token insertion and deletion mechanism).
  ///
  /// [recognizer] is the parser where got the error. From this object, you can
  /// access the context as well as the input source.
  /// [offendingSymbol] is the offending token in the input token source,
  /// unless recognizer is a lexer (then it's `null`). If no viable alternative
  /// error, [exception] has token at which we started production for the
  /// decision.
  /// [line] is the line number in the input where the error occurred.
  /// [charPositionInLine] is the character position within that line where
  /// the error occurred.
  /// [message] is the message to emit.
  /// [exception] is the exception generated by the parser that led to the
  /// reporting of an error. It is `null` in the case where the parser was
  /// able to recover in line without exiting the surrounding rule.
  void syntaxError(Recognizer recognizer, Object offendingSymbol, int line,
      int charPositionInLine, String message, RecognitionException exception) {}

  /// This method is called by the parser when a full-context prediction
  /// results in an ambiguity.
  ///
  /// When [exact] is `true`, **all** of the alternatives in [ambigAlts] are
  /// viable, i.e. this is reporting an exact ambiguity.
  /// [exact] is `false`, **at least two** of the alternatives in [ambigAlts]
  /// are viable for the current input, but the prediction algorithm terminated
  /// as soon as it determined that at least the **minimum** alternative in
  /// [ambigAlts] is viable.
  ///
  /// When the [PredictionMode.LL_EXACT_AMBIG_DETECTION] prediction mode
  /// is used, the parser is required to identify exact ambiguities so
  /// [exact] will always be `true`.
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] is the input index where the decision started.
  /// [stopIndex] is the input input where the ambiguity is reported.
  /// [exact] is `true` if the ambiguity is exactly known, otherwise `false`.
  /// This is always `true` when [PredictionMode.LL_EXACT_AMBIG_DETECTION]
  /// is used.
  /// [ambigAlts] is the potentially ambiguous alternatives.
  /// [configs] is the ATN configuration set where the ambiguity was
  /// determined.
  void reportAmbiguity(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, bool exact, BitSet ambigAlts, AtnConfigSet configs) {}

  /// This method is called when an SLL conflict occurs and the parser is about
  /// to use the full context information to make an LL decision.
  ///
  /// If one or more configurations in [configs] contains a semantic
  /// predicate, the predicates are evaluated before this method is called.
  /// The subset of alternatives which are still viable after predicates are
  /// evaluated is reported in [conflictingAlts].
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] is the input index where the decision started.
  /// [stopIndex] is the input index where the SLL conflict occurred.
  /// [conflictingAlts] is the specific conflicting alternatives. If this is
  /// `null`, the conflicting alternatives are all alternatives represented
  /// in [configs].
  /// [configs] is the ATN configuration set where the SLL conflict was
  /// detected.
  void reportAttemptingFullContext(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, BitSet conflictingAlts, AtnConfigSet configs) {}

  /// This method is called by the parser when a full-context prediction has a
  /// unique result.
  ///
  /// For prediction implementations that only evaluate full-context
  /// predictions when an SLL conflict is found (including the default
  /// [ParserAtnSimulator] implementation), this method reports cases
  /// where SLL conflicts were resolved to unique full-context predictions,
  /// i.e. the decision was context-sensitive. This report does not necessarily
  /// indicate a problem, and it may appear even in completely unambiguous
  /// grammars.
  ///
  /// [configs] may have more than one represented alternative if the
  /// full-context prediction algorithm does not evaluate predicates before
  /// beginning the full-context prediction. In all cases, the final prediction
  /// is passed as the [prediction] argument.
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] the input index where the decision started.
  /// [stopIndex] is the input index where the context sensitivity was
  /// finally determined.
  /// [prediction] is the unambiguous result of the full-context prediction.
  /// [configs] is the ATN configuration set where the unambiguous prediction
  /// was determined.
  void reportContextSensitivity(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, int prediction, AtnConfigSet configs) {}
}

class ConsoleErrorListener extends ErrorListener {
  static final ConsoleErrorListener INSTANCE = new ConsoleErrorListener();

  void syntaxError(Recognizer recognizer, Object offendingSymbol, int line,
      int charPositionInLine, String msg, RecognitionException e) {
    print("line $line:$charPositionInLine $msg");
  }
}

/// This implementation of [ErrorListener] dispatches all calls to a
/// collection of delegate listeners. This reduces the effort required
/// to support multiple listeners.
class ProxyErrorListener implements ErrorListener {
  final Iterable delegates;

  ProxyErrorListener(this.delegates) {
    assert(delegates != null);
  }

  void syntaxError(Recognizer recognizer, Object offendingSymbol, int line,
      int charPositionInLine, String message, RecognitionException exception) {
    delegates.forEach((delegate) {
      delegate.syntaxError(recognizer, offendingSymbol, line,
          charPositionInLine, message, exception);
    });
  }

  void reportAmbiguity(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, bool exact, BitSet ambigAlts, AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportAmbiguity(
          recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    });
  }

  void reportAttemptingFullContext(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, BitSet conflictingAlts, AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportAttemptingFullContext(
          recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);
    });
  }

  void reportContextSensitivity(Parser recognizer, Dfa dfa, int startIndex,
      int stopIndex, int prediction, AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportContextSensitivity(
          recognizer, dfa, startIndex, stopIndex, prediction, configs);
    });
  }
}
